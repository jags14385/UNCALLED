#!/usr/bin/env python3

# MIT License
#
# Copyright (c) 2018 Sam Kovaka <skovaka@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import sys                         
import os
import argparse
import time
import re
import time
import subprocess
import traceback
import uncalled as unc
import numpy as np

MAX_SLEEP = 0.01

def fast5_path(fname):
    if fname.startswith("#") or not fname.endswith("fast5"):
        return None

    path = os.path.abspath(fname)
    if not os.path.isfile(path):
        sys.stderr.write("Warning: \"%s\" is not a fast5 file.\n" % fname)
        return None

    return path

def load_fast5s(fast5s, recursive):
    for path in fast5s:
        path = path.strip()

        if not os.path.exists(path):
            sys.stderr.write("Error: \"%s\" does not exist\n" % path)
            sys.exit(1)

        isdir = os.path.isdir(path)

        #Recursive directory search 
        if isdir and recursive:
            for root, dirs, files in os.walk(path):
                for fname in files:
                    yield fast5_path(os.path.join(root, fname))

        #Non-recursive directory search 
        elif isdir and not recursive:
            for fname in os.listdir(path):
                yield fast5_path(os.path.join(path, fname))

        #Read fast5 name directly
        elif path.endswith(".fast5"):
            yield fast5_path(path)

        #Read fast5 filenames from text file
        else:
            with open(path) as infile:
                for line in infile:
                    yield fast5_path(line.strip())

def assert_exists(fname):
    if not os.path.exists(fname):
        sys.stderr.write("Error: '%s' does not exist\n" % fname)
        sys.exit(1)

#TODO fix
def list_ports_cmd(conf):
    log_re = re.compile("^([0-9\-]+ [0-9:]+).+ :.+instance_started.+")
    port_re = re.compile("grpc_port = (\d+)")
    device_re = re.compile("(device_id|instance) = ([^\s,]+)")

    fnames = os.listdir(conf.log_dir)
    log_fnames = list(sorted( (f for f in fnames if f.startswith("mk_manager_svc")) ))
    latest_log = os.path.join(conf.log_dir, log_fnames[-1])

    for line in open(latest_log):
        lm = log_re.match(line)
        if not lm: continue
        pm = port_re.search(line)
        dm = device_re.search(line)

        if pm is None or dm is None:
            sys.stderr.write("Error: failed to parse \"%s\"\n" % line.strip())
            continue

        timestamp = lm.group(1)
        port = pm.group(1)
        device = dm.group(2)

        sys.stdout.write("%s (%s): %s\n" % (device, timestamp, port))


if __name__ == "__main__":
    SUBCMDS = {
        "index" : (
            "Builds the UNCALLED index of a FASTA reference", 
            unc.index.OPTS
        ),
        "map" : (
            "Map fast5 files to a DNA reference",
            unc.index.BWA_OPTS + unc.fast5.FAST5_OPTS + unc.map.OPTS
        ),
        "realtime" : (
            "Perform real-time targeted (ReadUntil) sequencing",
            unc.index.BWA_OPTS + unc.map.OPTS + unc.realtime.OPTS #TODO ADD RU OPTS!!
        ),
        "sim" : (
            "Simulate real-time targeted sequencing.", 
            unc.index.BWA_OPTS + unc.sim.OPTS + unc.map.OPTS #TODO ADD RU OPTS!!
        ),
        "pafstats" : (
            "Computes speed and accuracy of UNCALLED mappings.",
            unc.pafstats.PAFSTATS_OPTS
        )
    }

    args = unc.ArgParser(subcmds=SUBCMDS)
    conf = args.conf

    if conf.subcmd == "index":
        unc.index.run(conf)
    elif conf.subcmd == "map":
        map_cmd(conf)
    elif conf.subcmd in {"sim", "realtime"}:
        realtime_cmd(conf)
    elif conf.subcmd == "list-ports":
        list_ports_cmd(conf)
    elif conf.subcmd == "pafstats":
        unc.pafstats.run(conf)
    else:
        args.parser.print_help()
        
