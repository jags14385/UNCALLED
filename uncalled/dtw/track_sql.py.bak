#!/usr/bin/env python3

import sys, os
import numpy as np
import sqlite3

class TrackIOParams(ParamGroup):
    _name = "track_io"
TrackIOParams.def_params(
    ("path", None, None, "Path to directory where alignments are stored"),
)

class TrackSQL:
    def __init__(self, sqlite_db, track_io_prms):
        self.con = sqlite3.connect(self.db_filename)
        #self.prms = track_io_prms

    def write_aln(self, aln):
        cur = self.con.cursor()
        cur.execute("INSERT INTO \"%s.alns\" VALUES (?,?,?,?,?,?)" % self.prms.name,
                     (aln.aln_id, aln.read_id, aln.ref_name, aln.ref_start, aln.ref_end, aln.is_fwd))
        print(cur.lastrowid)

    def write_layers(self, table, df):
        df.to_sql(table, self.con, if_exists="append", index=True, index_label="mref")

    def query(self, track_id, ref_coords, full_overlap):

        if ref_bounds is not None:
            self.prms.ref_bounds = ref_bounds

        self.set_ref_bounds(self.prms.ref_bounds)

        select = "SELECT mref, \"%s.dtw\".aln_id, start, length, current FROM \"%s.dtw\"" 
        where = " WHERE (mref >= ? AND mref <= ?)"
        params = [self._mrefs[1].min(), self._mrefs[1].max()]
        name_count = 2


        if self.prms.full_overlap:
            select = select + " JOIN \"%s.alns\" ON \"%s.alns\".aln_id = \"%s.dtw\".aln_id"
            where = where + " AND (ref_start < ? AND ref_end > ?)"
            params += [self.ref_coords.index[0], self.ref_coords.index[-1]]
            name_count += 3

        query = select + where
        fmt = ((self.prms.name,)*name_count)

        mat_df = pd.read_sql_query(
            query % fmt, self.con, params=params,
        ).pivot(index="aln_id", columns="mref") \
         .rename(columns=self.mref_to_ref, level="mref") \
         .rename_axis(["layer","ref"], axis=1) \
         .sort_index(axis=1, level=1)

        self.reads = pd.read_sql_query(
            "SELECT * FROM \"%s.alns\" WHERE aln_id IN (%s)" 
            % (self.prms.name, ",".join(["?"]*len(mat_df))),
            self.con, params=mat_df.index
        ).rename(columns={"read_id" : "id"}).sort_values("ref_start")

        
    def _init_tables(self):
        cur = self.con.cursor()
        cur.execute("""
            CREATE TABLE IF NOT EXISTS "%s.alns" (
                aln_id INTEGER PRIMARY KEY,
                read_id TEXT,
                ref_name TEXT,
                ref_start INTEGER,
                ref_end INTEGER,
                fwd INTEGER
            );""" % self.prms.name)
        cur.execute("""
            CREATE TABLE IF NOT EXISTS "%s.dtw" (
                mref INTEGER,
                aln_id INTEGER,
                start INTEGER,
                length INTEGER,
                current REAL,
                PRIMARY KEY (mref, aln_id),
                FOREIGN KEY (aln_id) REFERENCES "%s.dtw" (aln_id)
            );""" % (self.prms.name, self.prms.name))
        self.con.commit()
